
<!DOCTYPE html>
<html lang="zh_CN">
    <head>
        <meta charset="utf-8" />
        <title>分布式搜索引擎01 | ilovend的博客</title>
        <meta name="author" content="ilovend" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/images/favicon.png" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>加载过慢请开启缓存 浏览器默认开启</p>
                        <img src="/images/loading.gif" />
                    </div>
                </div>
            </transition>
            <nav id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <div id="desktop-menu">
        <a class="title" href="/">
            <span>ILOVEND的博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;ILOVEND的博客</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </div>
</nav>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <transition name="into">
                <div id="main" v-show="!loading">
                    <div class="article">
    <div>
        <h1>分布式搜索引擎01</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/5/24
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%86%85%E5%AE%B9/" style="color: #ffa2c4">项目内容</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="分布式搜索引擎01"><a href="#分布式搜索引擎01" class="headerlink" title="分布式搜索引擎01"></a>分布式搜索引擎01</h1><p>– elasticsearch基础</p>
<h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><h1 id="1-初识elasticsearch"><a href="#1-初识elasticsearch" class="headerlink" title="1.初识elasticsearch"></a>1.初识elasticsearch</h1><h2 id="1-1-了解ES"><a href="#1-1-了解ES" class="headerlink" title="1.1.了解ES"></a>1.1.了解ES</h2><h3 id="1-1-1-elasticsearch的作用"><a href="#1-1-1-elasticsearch的作用" class="headerlink" title="1.1.1.elasticsearch的作用"></a>1.1.1.elasticsearch的作用</h3><p>elasticsearch是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容</p>
<p>例如：</p>
<ul>
<li><p>在GitHub搜索代码</p>
<p><img src="/assets/image-20210720193623245.png" alt="image-20210720193623245"></p>
</li>
<li><p>在电商网站搜索商品</p>
<p><img src="/assets/image-20210720193633483.png" alt="image-20210720193633483"></p>
</li>
<li><p>在百度搜索答案</p>
<p><img src="/assets/image-20210720193641907.png" alt="image-20210720193641907"></p>
</li>
<li><p>在打车软件搜索附近的车</p>
<p><img src="/assets/image-20210720193648044.png" alt="image-20210720193648044"></p>
</li>
</ul>
<h3 id="1-1-2-ELK技术栈"><a href="#1-1-2-ELK技术栈" class="headerlink" title="1.1.2.ELK技术栈"></a>1.1.2.ELK技术栈</h3><p>elasticsearch结合kibana、Logstash、Beats，也就是elastic stack（ELK）。被广泛应用在日志数据分析、实时监控等领域：</p>
<p><img src="/assets/image-20210720194008781.png" alt="image-20210720194008781"></p>
<p>而elasticsearch是elastic stack的核心，负责存储、搜索、分析数据。</p>
<p><img src="/assets/image-20210720194230265.png" alt="image-20210720194230265"></p>
<h3 id="1-1-3-elasticsearch和lucene"><a href="#1-1-3-elasticsearch和lucene" class="headerlink" title="1.1.3.elasticsearch和lucene"></a>1.1.3.elasticsearch和lucene</h3><p>elasticsearch底层是基于<strong>lucene</strong>来实现的。</p>
<p><strong>Lucene</strong>是一个Java语言的搜索引擎类库，是Apache公司的顶级项目，由DougCutting于1999年研发。官网地址：<a target="_blank" rel="noopener" href="https://lucene.apache.org/">https://lucene.apache.org/</a> 。</p>
<p><img src="/assets/image-20210720194547780.png" alt="image-20210720194547780"></p>
<p><strong>elasticsearch</strong>的发展历史：</p>
<ul>
<li>2004年Shay Banon基于Lucene开发了Compass</li>
<li>2010年Shay Banon 重写了Compass，取名为Elasticsearch。</li>
</ul>
<p><img src="/assets/image-20210720195001221.png" alt="image-20210720195001221"></p>
<h3 id="1-1-4-为什么不是其他搜索技术？"><a href="#1-1-4-为什么不是其他搜索技术？" class="headerlink" title="1.1.4.为什么不是其他搜索技术？"></a>1.1.4.为什么不是其他搜索技术？</h3><p>目前比较知名的搜索引擎技术排名：</p>
<p><img src="/assets/image-20210720195142535.png" alt="image-20210720195142535"></p>
<p>虽然在早期，Apache Solr是最主要的搜索引擎技术，但随着发展elasticsearch已经渐渐超越了Solr，独占鳌头：</p>
<p><img src="/assets/image-20210720195306484.png" alt="image-20210720195306484"></p>
<h3 id="1-1-5-总结"><a href="#1-1-5-总结" class="headerlink" title="1.1.5.总结"></a>1.1.5.总结</h3><p>什么是elasticsearch？</p>
<ul>
<li>一个开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能</li>
</ul>
<p>什么是elastic stack（ELK）？</p>
<ul>
<li>是以elasticsearch为核心的技术栈，包括beats、Logstash、kibana、elasticsearch</li>
</ul>
<p>什么是Lucene？</p>
<ul>
<li>是Apache的开源搜索引擎类库，提供了搜索引擎的核心API</li>
</ul>
<h2 id="1-2-倒排索引"><a href="#1-2-倒排索引" class="headerlink" title="1.2.倒排索引"></a>1.2.倒排索引</h2><p>倒排索引的概念是基于MySQL这样的正向索引而言的。</p>
<h3 id="1-2-1-正向索引"><a href="#1-2-1-正向索引" class="headerlink" title="1.2.1.正向索引"></a>1.2.1.正向索引</h3><p>那么什么是正向索引呢？例如给下表（tb_goods）中的id创建索引：</p>
<p><img src="/assets/image-20210720195531539.png" alt="image-20210720195531539"></p>
<p>如果是根据id查询，那么直接走索引，查询速度非常快。</p>
<p>但如果是基于title做模糊查询，只能是逐行扫描数据，流程如下：</p>
<p>1）用户搜索数据，条件是title符合<code>&quot;%手机%&quot;</code></p>
<p>2）逐行获取数据，比如id为1的数据</p>
<p>3）判断数据中的title是否符合用户搜索条件</p>
<p>4）如果符合则放入结果集，不符合则丢弃。回到步骤1</p>
<p>逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就是一场灾难。</p>
<h3 id="1-2-2-倒排索引"><a href="#1-2-2-倒排索引" class="headerlink" title="1.2.2.倒排索引"></a>1.2.2.倒排索引</h3><p>倒排索引中有两个非常重要的概念：</p>
<ul>
<li>文档（<code>Document</code>）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息</li>
<li>词条（<code>Term</code>）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</li>
</ul>
<p><strong>创建倒排索引</strong>是对正向索引的一种特殊处理，流程如下：</p>
<ul>
<li>将每一个文档的数据利用算法分词，得到一个个词条</li>
<li>创建表，每行数据包括词条、词条所在文档id、位置等信息</li>
<li>因为词条唯一性，可以给词条创建索引，例如hash表结构索引</li>
</ul>
<p>如图：</p>
<p><img src="/assets/image-20210720200457207.png" alt="image-20210720200457207"></p>
<p>倒排索引的<strong>搜索流程</strong>如下（以搜索”华为手机”为例）：</p>
<p>1）用户输入条件<code>&quot;华为手机&quot;</code>进行搜索。</p>
<p>2）对用户输入内容<strong>分词</strong>，得到词条：<code>华为</code>、<code>手机</code>。</p>
<p>3）拿着词条在倒排索引中查找，可以得到包含词条的文档id：1、2、3。</p>
<p>4）拿着文档id到正向索引中查找具体文档。</p>
<p>如图：</p>
<p><img src="/assets/image-20210720201115192.png" alt="image-20210720201115192"></p>
<p>虽然要先查询倒排索引，再查询倒排索引，但是无论是词条、还是文档id都建立了索引，查询速度非常快！无需全表扫描。</p>
<h3 id="1-2-3-正向和倒排"><a href="#1-2-3-正向和倒排" class="headerlink" title="1.2.3.正向和倒排"></a>1.2.3.正向和倒排</h3><p>那么为什么一个叫做正向索引，一个叫做倒排索引呢？</p>
<ul>
<li><p><strong>正向索引</strong>是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是<strong>根据文档找词条的过程</strong>。</p>
</li>
<li><p>而<strong>倒排索引</strong>则相反，是先找到用户要搜索的词条，根据词条得到保护词条的文档的id，然后根据id获取文档。是<strong>根据词条找文档的过程</strong>。</p>
</li>
</ul>
<p>是不是恰好反过来了？</p>
<p>那么两者方式的优缺点是什么呢？</p>
<p><strong>正向索引</strong>：</p>
<ul>
<li>优点：<ul>
<li>可以给多个字段创建索引</li>
<li>根据索引字段搜索、排序速度非常快</li>
</ul>
</li>
<li>缺点：<ul>
<li>根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描。</li>
</ul>
</li>
</ul>
<p><strong>倒排索引</strong>：</p>
<ul>
<li>优点：<ul>
<li>根据词条搜索、模糊搜索时，速度非常快</li>
</ul>
</li>
<li>缺点：<ul>
<li>只能给词条创建索引，而不是字段</li>
<li>无法根据字段做排序</li>
</ul>
</li>
</ul>
<h2 id="1-3-es的一些概念"><a href="#1-3-es的一些概念" class="headerlink" title="1.3.es的一些概念"></a>1.3.es的一些概念</h2><p>elasticsearch中有很多独有的概念，与mysql中略有差别，但也有相似之处。</p>
<h3 id="1-3-1-文档和字段"><a href="#1-3-1-文档和字段" class="headerlink" title="1.3.1.文档和字段"></a>1.3.1.文档和字段</h3><p>elasticsearch是面向<strong>文档（Document）</strong>存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为json格式后存储在elasticsearch中：</p>
<p><img src="/assets/image-20210720202707797.png" alt="image-20210720202707797"></p>
<p>而Json文档中往往包含很多的<strong>字段（Field）</strong>，类似于数据库中的列。</p>
<h3 id="1-3-2-索引和映射"><a href="#1-3-2-索引和映射" class="headerlink" title="1.3.2.索引和映射"></a>1.3.2.索引和映射</h3><p><strong>索引（Index）</strong>，就是相同类型的文档的集合。</p>
<p>例如：</p>
<ul>
<li>所有用户文档，就可以组织在一起，称为用户的索引；</li>
<li>所有商品的文档，可以组织在一起，称为商品的索引；</li>
<li>所有订单的文档，可以组织在一起，称为订单的索引；</li>
</ul>
<p><img src="/assets/image-20210720203022172.png" alt="image-20210720203022172"></p>
<p>因此，我们可以把索引当做是数据库中的表。</p>
<p>数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有<strong>映射（mapping）</strong>，是索引中文档的字段约束信息，类似表的结构约束。</p>
<h3 id="1-3-3-mysql与elasticsearch"><a href="#1-3-3-mysql与elasticsearch" class="headerlink" title="1.3.3.mysql与elasticsearch"></a>1.3.3.mysql与elasticsearch</h3><p>我们统一的把mysql与elasticsearch的概念做一下对比：</p>
<table>
<thead>
<tr>
<th><strong>MySQL</strong></th>
<th><strong>Elasticsearch</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Table</td>
<td>Index</td>
<td>索引(index)，就是文档的集合，类似数据库的表(table)</td>
</tr>
<tr>
<td>Row</td>
<td>Document</td>
<td>文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td>
</tr>
<tr>
<td>Column</td>
<td>Field</td>
<td>字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td>
</tr>
<tr>
<td>Schema</td>
<td>Mapping</td>
<td>Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td>
</tr>
<tr>
<td>SQL</td>
<td>DSL</td>
<td>DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td>
</tr>
</tbody></table>
<p>是不是说，我们学习了elasticsearch就不再需要mysql了呢？</p>
<p>并不是如此，两者各自有自己的擅长支出：</p>
<ul>
<li><p>Mysql：擅长事务类型操作，可以确保数据的安全和一致性</p>
</li>
<li><p>Elasticsearch：擅长海量数据的搜索、分析、计算</p>
</li>
</ul>
<p>因此在企业中，往往是两者结合使用：</p>
<ul>
<li>对安全性要求较高的写操作，使用mysql实现</li>
<li>对查询性能要求较高的搜索需求，使用elasticsearch实现</li>
<li>两者再基于某种方式，实现数据的同步，保证一致性</li>
</ul>
<p><img src="/assets/image-20210720203534945.png" alt="image-20210720203534945"></p>
<h2 id="1-4-安装es、kibana"><a href="#1-4-安装es、kibana" class="headerlink" title="1.4.安装es、kibana"></a>1.4.安装es、kibana</h2><h3 id="1-4-1-安装"><a href="#1-4-1-安装" class="headerlink" title="1.4.1.安装"></a>1.4.1.安装</h3><p>参考课前资料：</p>
<p><img src="/assets/image-20210720203805350.png" alt="image-20210720203805350"> </p>
<h3 id="1-4-2-分词器"><a href="#1-4-2-分词器" class="headerlink" title="1.4.2.分词器"></a>1.4.2.分词器</h3><p>参考课前资料：</p>
<p><img src="/assets/image-20210720203805350.png" alt="image-20210720203805350"> </p>
<h3 id="1-4-3-总结"><a href="#1-4-3-总结" class="headerlink" title="1.4.3.总结"></a>1.4.3.总结</h3><p>分词器的作用是什么？</p>
<ul>
<li>创建倒排索引时对文档分词</li>
<li>用户搜索时，对输入的内容分词</li>
</ul>
<p>IK分词器有几种模式？</p>
<ul>
<li>ik_smart：智能切分，粗粒度</li>
<li>ik_max_word：最细切分，细粒度</li>
</ul>
<p>IK分词器如何拓展词条？如何停用词条？</p>
<ul>
<li>利用config目录的IkAnalyzer.cfg.xml文件添加拓展词典和停用词典</li>
<li>在词典中添加拓展词条或者停用词条</li>
</ul>
<h1 id="2-索引库操作"><a href="#2-索引库操作" class="headerlink" title="2.索引库操作"></a>2.索引库操作</h1><p>索引库就类似数据库表，mapping映射就类似表的结构。</p>
<p>我们要向es中存储数据，必须先创建“库”和“表”。</p>
<h2 id="2-1-mapping映射属性"><a href="#2-1-mapping映射属性" class="headerlink" title="2.1.mapping映射属性"></a>2.1.mapping映射属性</h2><p>mapping是对索引库中文档的约束，常见的mapping属性包括：</p>
<ul>
<li>type：字段数据类型，常见的简单类型有：<ul>
<li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li>
<li>数值：long、integer、short、byte、double、float、</li>
<li>布尔：boolean</li>
<li>日期：date</li>
<li>对象：object</li>
</ul>
</li>
<li>index：是否创建索引，默认为true</li>
<li>analyzer：使用哪种分词器</li>
<li>properties：该字段的子字段</li>
</ul>
<p>例如下面的json文档：</p>
<pre><code class="json">&#123;
    &quot;age&quot;: 21,
    &quot;weight&quot;: 52.1,
    &quot;isMarried&quot;: false,
    &quot;info&quot;: &quot;黑马程序员Java讲师&quot;,
    &quot;email&quot;: &quot;zy@itcast.cn&quot;,
    &quot;score&quot;: [99.1, 99.5, 98.9],
    &quot;name&quot;: &#123;
        &quot;firstName&quot;: &quot;云&quot;,
        &quot;lastName&quot;: &quot;赵&quot;
    &#125;
&#125;
</code></pre>
<p>对应的每个字段映射（mapping）：</p>
<ul>
<li>age：类型为 integer；参与搜索，因此需要index为true；无需分词器</li>
<li>weight：类型为float；参与搜索，因此需要index为true；无需分词器</li>
<li>isMarried：类型为boolean；参与搜索，因此需要index为true；无需分词器</li>
<li>info：类型为字符串，需要分词，因此是text；参与搜索，因此需要index为true；分词器可以用ik_smart</li>
<li>email：类型为字符串，但是不需要分词，因此是keyword；不参与搜索，因此需要index为false；无需分词器</li>
<li>score：虽然是数组，但是我们只看元素的类型，类型为float；参与搜索，因此需要index为true；无需分词器</li>
<li>name：类型为object，需要定义多个子属性<ul>
<li>name.firstName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器</li>
<li>name.lastName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器</li>
</ul>
</li>
</ul>
<h2 id="2-2-索引库的CRUD"><a href="#2-2-索引库的CRUD" class="headerlink" title="2.2.索引库的CRUD"></a>2.2.索引库的CRUD</h2><p>这里我们统一使用Kibana编写DSL的方式来演示。</p>
<h3 id="2-2-1-创建索引库和映射"><a href="#2-2-1-创建索引库和映射" class="headerlink" title="2.2.1.创建索引库和映射"></a>2.2.1.创建索引库和映射</h3><h4 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h4><ul>
<li>请求方式：PUT</li>
<li>请求路径：&#x2F;索引库名，可以自定义</li>
<li>请求参数：mapping映射</li>
</ul>
<p>格式：</p>
<pre><code class="json">PUT /索引库名称
&#123;
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      &quot;字段名&quot;:&#123;
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_smart&quot;
      &#125;,
      &quot;字段名2&quot;:&#123;
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: &quot;false&quot;
      &#125;,
      &quot;字段名3&quot;:&#123;
        &quot;properties&quot;: &#123;
          &quot;子字段&quot;: &#123;
            &quot;type&quot;: &quot;keyword&quot;
          &#125;
        &#125;
      &#125;,
      // ...略
    &#125;
  &#125;
&#125;
</code></pre>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><pre><code class="sh">PUT /heima
&#123;
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      &quot;info&quot;:&#123;
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_smart&quot;
      &#125;,
      &quot;email&quot;:&#123;
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: &quot;falsae&quot;
      &#125;,
      &quot;name&quot;:&#123;
        &quot;properties&quot;: &#123;
          &quot;firstName&quot;: &#123;
            &quot;type&quot;: &quot;keyword&quot;
          &#125;
        &#125;
      &#125;,
      // ... 略
    &#125;
  &#125;
&#125;
</code></pre>
<h3 id="2-2-2-查询索引库"><a href="#2-2-2-查询索引库" class="headerlink" title="2.2.2.查询索引库"></a>2.2.2.查询索引库</h3><p><strong>基本语法</strong>：</p>
<ul>
<li><p>请求方式：GET</p>
</li>
<li><p>请求路径：&#x2F;索引库名</p>
</li>
<li><p>请求参数：无</p>
</li>
</ul>
<p><strong>格式</strong>：</p>
<pre><code>GET /索引库名
</code></pre>
<p><strong>示例</strong>：</p>
<p><img src="/assets/image-20210720211019329.png" alt="image-20210720211019329"></p>
<h3 id="2-2-3-修改索引库"><a href="#2-2-3-修改索引库" class="headerlink" title="2.2.3.修改索引库"></a>2.2.3.修改索引库</h3><p>倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库<strong>一旦创建，无法修改mapping</strong>。</p>
<p>虽然无法修改mapping中已有的字段，但是却允许添加新的字段到mapping中，因为不会对倒排索引产生影响。</p>
<p><strong>语法说明</strong>：</p>
<pre><code class="json">PUT /索引库名/_mapping
&#123;
  &quot;properties&quot;: &#123;
    &quot;新字段名&quot;:&#123;
      &quot;type&quot;: &quot;integer&quot;
    &#125;
  &#125;
&#125;
</code></pre>
<p><strong>示例</strong>：</p>
<p><img src="/assets/image-20210720212357390.png" alt="image-20210720212357390"></p>
<h3 id="2-2-4-删除索引库"><a href="#2-2-4-删除索引库" class="headerlink" title="2.2.4.删除索引库"></a>2.2.4.删除索引库</h3><p><strong>语法：</strong></p>
<ul>
<li><p>请求方式：DELETE</p>
</li>
<li><p>请求路径：&#x2F;索引库名</p>
</li>
<li><p>请求参数：无</p>
</li>
</ul>
<p><strong>格式：</strong></p>
<pre><code>DELETE /索引库名
</code></pre>
<p>在kibana中测试：</p>
<p><img src="/assets/image-20210720212123420.png" alt="image-20210720212123420"></p>
<h3 id="2-2-5-总结"><a href="#2-2-5-总结" class="headerlink" title="2.2.5.总结"></a>2.2.5.总结</h3><p>索引库操作有哪些？</p>
<ul>
<li>创建索引库：PUT &#x2F;索引库名</li>
<li>查询索引库：GET &#x2F;索引库名</li>
<li>删除索引库：DELETE &#x2F;索引库名</li>
<li>添加字段：PUT &#x2F;索引库名&#x2F;_mapping</li>
</ul>
<h1 id="3-文档操作"><a href="#3-文档操作" class="headerlink" title="3.文档操作"></a>3.文档操作</h1><h2 id="3-1-新增文档"><a href="#3-1-新增文档" class="headerlink" title="3.1.新增文档"></a>3.1.新增文档</h2><p><strong>语法：</strong></p>
<pre><code class="json">POST /索引库名/_doc/文档id
&#123;
    &quot;字段1&quot;: &quot;值1&quot;,
    &quot;字段2&quot;: &quot;值2&quot;,
    &quot;字段3&quot;: &#123;
        &quot;子属性1&quot;: &quot;值3&quot;,
        &quot;子属性2&quot;: &quot;值4&quot;
    &#125;,
    // ...
&#125;
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="json">POST /heima/_doc/1
&#123;
    &quot;info&quot;: &quot;黑马程序员Java讲师&quot;,
    &quot;email&quot;: &quot;zy@itcast.cn&quot;,
    &quot;name&quot;: &#123;
        &quot;firstName&quot;: &quot;云&quot;,
        &quot;lastName&quot;: &quot;赵&quot;
    &#125;
&#125;
</code></pre>
<p><strong>响应：</strong></p>
<p><img src="/assets/image-20210720212933362.png" alt="image-20210720212933362"></p>
<h2 id="3-2-查询文档"><a href="#3-2-查询文档" class="headerlink" title="3.2.查询文档"></a>3.2.查询文档</h2><p>根据rest风格，新增是post，查询应该是get，不过查询一般都需要条件，这里我们把文档id带上。</p>
<p><strong>语法：</strong></p>
<pre><code class="json">GET /&#123;索引库名称&#125;/_doc/&#123;id&#125;
</code></pre>
<p><strong>通过kibana查看数据：</strong></p>
<pre><code class="js">GET /heima/_doc/1
</code></pre>
<p><strong>查看结果：</strong></p>
<p><img src="/assets/image-20210720213345003.png" alt="image-20210720213345003"></p>
<h2 id="3-3-删除文档"><a href="#3-3-删除文档" class="headerlink" title="3.3.删除文档"></a>3.3.删除文档</h2><p>删除使用DELETE请求，同样，需要根据id进行删除：</p>
<p><strong>语法：</strong></p>
<pre><code class="js">DELETE /&#123;索引库名&#125;/_doc/id值
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="json"># 根据id删除数据
DELETE /heima/_doc/1
</code></pre>
<p><strong>结果：</strong></p>
<p><img src="/assets/image-20210720213634918.png" alt="image-20210720213634918"></p>
<h2 id="3-4-修改文档"><a href="#3-4-修改文档" class="headerlink" title="3.4.修改文档"></a>3.4.修改文档</h2><p>修改有两种方式：</p>
<ul>
<li>全量修改：直接覆盖原来的文档</li>
<li>增量修改：修改文档中的部分字段</li>
</ul>
<h3 id="3-4-1-全量修改"><a href="#3-4-1-全量修改" class="headerlink" title="3.4.1.全量修改"></a>3.4.1.全量修改</h3><p>全量修改是覆盖原来的文档，其本质是：</p>
<ul>
<li>根据指定的id删除文档</li>
<li>新增一个相同id的文档</li>
</ul>
<p><strong>注意</strong>：如果根据id删除时，id不存在，第二步的新增也会执行，也就从修改变成了新增操作了。</p>
<p><strong>语法：</strong></p>
<pre><code class="json">PUT /&#123;索引库名&#125;/_doc/文档id
&#123;
    &quot;字段1&quot;: &quot;值1&quot;,
    &quot;字段2&quot;: &quot;值2&quot;,
    // ... 略
&#125;
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="json">PUT /heima/_doc/1
&#123;
    &quot;info&quot;: &quot;黑马程序员高级Java讲师&quot;,
    &quot;email&quot;: &quot;zy@itcast.cn&quot;,
    &quot;name&quot;: &#123;
        &quot;firstName&quot;: &quot;云&quot;,
        &quot;lastName&quot;: &quot;赵&quot;
    &#125;
&#125;
</code></pre>
<h3 id="3-4-2-增量修改"><a href="#3-4-2-增量修改" class="headerlink" title="3.4.2.增量修改"></a>3.4.2.增量修改</h3><p>增量修改是只修改指定id匹配的文档中的部分字段。</p>
<p><strong>语法：</strong></p>
<pre><code class="json">POST /&#123;索引库名&#125;/_update/文档id
&#123;
    &quot;doc&quot;: &#123;
         &quot;字段名&quot;: &quot;新的值&quot;,
    &#125;
&#125;
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="json">POST /heima/_update/1
&#123;
  &quot;doc&quot;: &#123;
    &quot;email&quot;: &quot;ZhaoYun@itcast.cn&quot;
  &#125;
&#125;
</code></pre>
<h2 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5.总结"></a>3.5.总结</h2><p>文档操作有哪些？</p>
<ul>
<li>创建文档：POST &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id   { json文档 }</li>
<li>查询文档：GET &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id</li>
<li>删除文档：DELETE &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id</li>
<li>修改文档：<ul>
<li>全量修改：PUT &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id { json文档 }</li>
<li>增量修改：POST &#x2F;{索引库名}&#x2F;_update&#x2F;文档id { “doc”: {字段}}</li>
</ul>
</li>
</ul>
<h1 id="4-RestAPI"><a href="#4-RestAPI" class="headerlink" title="4.RestAPI"></a>4.RestAPI</h1><p>ES官方提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过http请求发送给ES。官方文档地址：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a></p>
<p>其中的Java Rest Client又包括两种：</p>
<ul>
<li>Java Low Level Rest Client</li>
<li>Java High Level Rest Client</li>
</ul>
<p><img src="/assets/image-20210720214555863.png" alt="image-20210720214555863"></p>
<p>我们学习的是Java HighLevel Rest Client客户端API</p>
<h2 id="4-0-导入Demo工程"><a href="#4-0-导入Demo工程" class="headerlink" title="4.0.导入Demo工程"></a>4.0.导入Demo工程</h2><h3 id="4-0-1-导入数据"><a href="#4-0-1-导入数据" class="headerlink" title="4.0.1.导入数据"></a>4.0.1.导入数据</h3><p>首先导入课前资料提供的数据库数据：</p>
<p><img src="/assets/image-20210720220400297.png" alt="image-20210720220400297"> </p>
<p>数据结构如下：</p>
<pre><code class="sql">CREATE TABLE `tb_hotel` (
  `id` bigint(20) NOT NULL COMMENT &#39;酒店id&#39;,
  `name` varchar(255) NOT NULL COMMENT &#39;酒店名称；例：7天酒店&#39;,
  `address` varchar(255) NOT NULL COMMENT &#39;酒店地址；例：航头路&#39;,
  `price` int(10) NOT NULL COMMENT &#39;酒店价格；例：329&#39;,
  `score` int(2) NOT NULL COMMENT &#39;酒店评分；例：45，就是4.5分&#39;,
  `brand` varchar(32) NOT NULL COMMENT &#39;酒店品牌；例：如家&#39;,
  `city` varchar(32) NOT NULL COMMENT &#39;所在城市；例：上海&#39;,
  `star_name` varchar(16) DEFAULT NULL COMMENT &#39;酒店星级，从低到高分别是：1星到5星，1钻到5钻&#39;,
  `business` varchar(255) DEFAULT NULL COMMENT &#39;商圈；例：虹桥&#39;,
  `latitude` varchar(32) NOT NULL COMMENT &#39;纬度；例：31.2497&#39;,
  `longitude` varchar(32) NOT NULL COMMENT &#39;经度；例：120.3925&#39;,
  `pic` varchar(255) DEFAULT NULL COMMENT &#39;酒店图片；例:/img/1.jpg&#39;,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
</code></pre>
<h3 id="4-0-2-导入项目"><a href="#4-0-2-导入项目" class="headerlink" title="4.0.2.导入项目"></a>4.0.2.导入项目</h3><p>然后导入课前资料提供的项目:</p>
<p><img src="/assets/image-20210720220503411.png" alt="image-20210720220503411"> </p>
<p>项目结构如图：</p>
<p><img src="/assets/image-20210720220647541.png" alt="image-20210720220647541"></p>
<h3 id="4-0-3-mapping映射分析"><a href="#4-0-3-mapping映射分析" class="headerlink" title="4.0.3.mapping映射分析"></a>4.0.3.mapping映射分析</h3><p>创建索引库，最关键的是mapping映射，而mapping映射要考虑的信息包括：</p>
<ul>
<li>字段名</li>
<li>字段数据类型</li>
<li>是否参与搜索</li>
<li>是否需要分词</li>
<li>如果分词，分词器是什么？</li>
</ul>
<p>其中：</p>
<ul>
<li>字段名、字段数据类型，可以参考数据表结构的名称和类型</li>
<li>是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索</li>
<li>是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词</li>
<li>分词器，我们可以统一使用ik_max_word</li>
</ul>
<p>来看下酒店数据的索引库结构:</p>
<pre><code class="json">PUT /hotel
&#123;
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      &quot;id&quot;: &#123;
        &quot;type&quot;: &quot;keyword&quot;
      &#125;,
      &quot;name&quot;:&#123;
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_max_word&quot;,
        &quot;copy_to&quot;: &quot;all&quot;
      &#125;,
      &quot;address&quot;:&#123;
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: false
      &#125;,
      &quot;price&quot;:&#123;
        &quot;type&quot;: &quot;integer&quot;
      &#125;,
      &quot;score&quot;:&#123;
        &quot;type&quot;: &quot;integer&quot;
      &#125;,
      &quot;brand&quot;:&#123;
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;copy_to&quot;: &quot;all&quot;
      &#125;,
      &quot;city&quot;:&#123;
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;copy_to&quot;: &quot;all&quot;
      &#125;,
      &quot;starName&quot;:&#123;
        &quot;type&quot;: &quot;keyword&quot;
      &#125;,
      &quot;business&quot;:&#123;
        &quot;type&quot;: &quot;keyword&quot;
      &#125;,
      &quot;location&quot;:&#123;
        &quot;type&quot;: &quot;geo_point&quot;
      &#125;,
      &quot;pic&quot;:&#123;
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: false
      &#125;,
      &quot;all&quot;:&#123;
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_max_word&quot;
      &#125;
    &#125;
  &#125;
&#125;
</code></pre>
<p>几个特殊字段说明：</p>
<ul>
<li>location：地理坐标，里面包含精度、纬度</li>
<li>all：一个组合字段，其目的是将多字段的值 利用copy_to合并，提供给用户搜索</li>
</ul>
<p>地理坐标说明：</p>
<p><img src="/assets/image-20210720222110126.png" alt="image-20210720222110126"></p>
<p>copy_to说明：</p>
<p><img src="/assets/image-20210720222221516.png" alt="image-20210720222221516"></p>
<h3 id="4-0-4-初始化RestClient"><a href="#4-0-4-初始化RestClient" class="headerlink" title="4.0.4.初始化RestClient"></a>4.0.4.初始化RestClient</h3><p>在elasticsearch提供的API中，与elasticsearch一切交互都封装在一个名为RestHighLevelClient的类中，必须先完成这个对象的初始化，建立与elasticsearch的连接。</p>
<p>分为三步：</p>
<p>1）引入es的RestHighLevelClient依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;
    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>2）因为SpringBoot默认的ES版本是7.6.2，所以我们需要覆盖默认的ES版本：</p>
<pre><code class="xml">&lt;properties&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;elasticsearch.version&gt;7.12.1&lt;/elasticsearch.version&gt;
&lt;/properties&gt;
</code></pre>
<p>3）初始化RestHighLevelClient：</p>
<p>初始化的代码如下：</p>
<pre><code class="java">RestHighLevelClient client = new RestHighLevelClient(RestClient.builder(
        HttpHost.create(&quot;http://192.168.150.101:9200&quot;)
));
</code></pre>
<p>这里为了单元测试方便，我们创建一个测试类HotelIndexTest，然后将初始化的代码编写在@BeforeEach方法中：</p>
<pre><code class="java">package cn.itcast.hotel;

import org.apache.http.HttpHost;
import org.elasticsearch.client.RestHighLevelClient;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.io.IOException;

public class HotelIndexTest &#123;
    private RestHighLevelClient client;

    @BeforeEach
    void setUp() &#123;
        this.client = new RestHighLevelClient(RestClient.builder(
                HttpHost.create(&quot;http://192.168.150.101:9200&quot;)
        ));
    &#125;

    @AfterEach
    void tearDown() throws IOException &#123;
        this.client.close();
    &#125;
&#125;
</code></pre>
<h2 id="4-1-创建索引库"><a href="#4-1-创建索引库" class="headerlink" title="4.1.创建索引库"></a>4.1.创建索引库</h2><h3 id="4-1-1-代码解读"><a href="#4-1-1-代码解读" class="headerlink" title="4.1.1.代码解读"></a>4.1.1.代码解读</h3><p>创建索引库的API如下：</p>
<p><img src="/assets/image-20210720223049408.png" alt="image-20210720223049408"></p>
<p>代码分为三步：</p>
<ul>
<li>1）创建Request对象。因为是创建索引库的操作，因此Request是CreateIndexRequest。</li>
<li>2）添加请求参数，其实就是DSL的JSON参数部分。因为json字符串很长，这里是定义了静态字符串常量MAPPING_TEMPLATE，让代码看起来更加优雅。</li>
<li>3）发送请求，client.indices()方法的返回值是IndicesClient类型，封装了所有与索引库操作有关的方法。</li>
</ul>
<h3 id="4-1-2-完整示例"><a href="#4-1-2-完整示例" class="headerlink" title="4.1.2.完整示例"></a>4.1.2.完整示例</h3><p>在hotel-demo的cn.itcast.hotel.constants包下，创建一个类，定义mapping映射的JSON字符串常量：</p>
<pre><code class="java">package cn.itcast.hotel.constants;

public class HotelConstants &#123;
    public static final String MAPPING_TEMPLATE = &quot;&#123;\n&quot; +
            &quot;  \&quot;mappings\&quot;: &#123;\n&quot; +
            &quot;    \&quot;properties\&quot;: &#123;\n&quot; +
            &quot;      \&quot;id\&quot;: &#123;\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot; +
            &quot;      &#125;,\n&quot; +
            &quot;      \&quot;name\&quot;:&#123;\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot; +
            &quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;,\n&quot; +
            &quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot; +
            &quot;      &#125;,\n&quot; +
            &quot;      \&quot;address\&quot;:&#123;\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot; +
            &quot;        \&quot;index\&quot;: false\n&quot; +
            &quot;      &#125;,\n&quot; +
            &quot;      \&quot;price\&quot;:&#123;\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot; +
            &quot;      &#125;,\n&quot; +
            &quot;      \&quot;score\&quot;:&#123;\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot; +
            &quot;      &#125;,\n&quot; +
            &quot;      \&quot;brand\&quot;:&#123;\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot; +
            &quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot; +
            &quot;      &#125;,\n&quot; +
            &quot;      \&quot;city\&quot;:&#123;\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot; +
            &quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot; +
            &quot;      &#125;,\n&quot; +
            &quot;      \&quot;starName\&quot;:&#123;\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot; +
            &quot;      &#125;,\n&quot; +
            &quot;      \&quot;business\&quot;:&#123;\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot; +
            &quot;      &#125;,\n&quot; +
            &quot;      \&quot;location\&quot;:&#123;\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;geo_point\&quot;\n&quot; +
            &quot;      &#125;,\n&quot; +
            &quot;      \&quot;pic\&quot;:&#123;\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot; +
            &quot;        \&quot;index\&quot;: false\n&quot; +
            &quot;      &#125;,\n&quot; +
            &quot;      \&quot;all\&quot;:&#123;\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot; +
            &quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;\n&quot; +
            &quot;      &#125;\n&quot; +
            &quot;    &#125;\n&quot; +
            &quot;  &#125;\n&quot; +
            &quot;&#125;&quot;;
&#125;
</code></pre>
<p>在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现创建索引：</p>
<pre><code class="java">@Test
void createHotelIndex() throws IOException &#123;
    // 1.创建Request对象
    CreateIndexRequest request = new CreateIndexRequest(&quot;hotel&quot;);
    // 2.准备请求的参数：DSL语句
    request.source(MAPPING_TEMPLATE, XContentType.JSON);
    // 3.发送请求
    client.indices().create(request, RequestOptions.DEFAULT);
&#125;
</code></pre>
<h2 id="4-2-删除索引库"><a href="#4-2-删除索引库" class="headerlink" title="4.2.删除索引库"></a>4.2.删除索引库</h2><p>删除索引库的DSL语句非常简单：</p>
<pre><code class="json">DELETE /hotel
</code></pre>
<p>与创建索引库相比：</p>
<ul>
<li>请求方式从PUT变为DELTE</li>
<li>请求路径不变</li>
<li>无请求参数</li>
</ul>
<p>所以代码的差异，注意体现在Request对象上。依然是三步走：</p>
<ul>
<li>1）创建Request对象。这次是DeleteIndexRequest对象</li>
<li>2）准备参数。这里是无参</li>
<li>3）发送请求。改用delete方法</li>
</ul>
<p>在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现删除索引：</p>
<pre><code class="java">@Test
void testDeleteHotelIndex() throws IOException &#123;
    // 1.创建Request对象
    DeleteIndexRequest request = new DeleteIndexRequest(&quot;hotel&quot;);
    // 2.发送请求
    client.indices().delete(request, RequestOptions.DEFAULT);
&#125;
</code></pre>
<h2 id="4-3-判断索引库是否存在"><a href="#4-3-判断索引库是否存在" class="headerlink" title="4.3.判断索引库是否存在"></a>4.3.判断索引库是否存在</h2><p>判断索引库是否存在，本质就是查询，对应的DSL是：</p>
<pre><code class="json">GET /hotel
</code></pre>
<p>因此与删除的Java代码流程是类似的。依然是三步走：</p>
<ul>
<li>1）创建Request对象。这次是GetIndexRequest对象</li>
<li>2）准备参数。这里是无参</li>
<li>3）发送请求。改用exists方法</li>
</ul>
<pre><code class="java">@Test
void testExistsHotelIndex() throws IOException &#123;
    // 1.创建Request对象
    GetIndexRequest request = new GetIndexRequest(&quot;hotel&quot;);
    // 2.发送请求
    boolean exists = client.indices().exists(request, RequestOptions.DEFAULT);
    // 3.输出
    System.err.println(exists ? &quot;索引库已经存在！&quot; : &quot;索引库不存在！&quot;);
&#125;
</code></pre>
<h2 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4.总结"></a>4.4.总结</h2><p>JavaRestClient操作elasticsearch的流程基本类似。核心是client.indices()方法来获取索引库的操作对象。</p>
<p>索引库操作的基本步骤：</p>
<ul>
<li>初始化RestHighLevelClient</li>
<li>创建XxxIndexRequest。XXX是Create、Get、Delete</li>
<li>准备DSL（ Create时需要，其它是无参）</li>
<li>发送请求。调用RestHighLevelClient#indices().xxx()方法，xxx是create、exists、delete</li>
</ul>
<h1 id="5-RestClient操作文档"><a href="#5-RestClient操作文档" class="headerlink" title="5.RestClient操作文档"></a>5.RestClient操作文档</h1><p>为了与索引库操作分离，我们再次参加一个测试类，做两件事情：</p>
<ul>
<li>初始化RestHighLevelClient</li>
<li>我们的酒店数据在数据库，需要利用IHotelService去查询，所以注入这个接口</li>
</ul>
<pre><code class="java">package cn.itcast.hotel;

import cn.itcast.hotel.pojo.Hotel;
import cn.itcast.hotel.service.IHotelService;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.io.IOException;
import java.util.List;

@SpringBootTest
public class HotelDocumentTest &#123;
    @Autowired
    private IHotelService hotelService;

    private RestHighLevelClient client;

    @BeforeEach
    void setUp() &#123;
        this.client = new RestHighLevelClient(RestClient.builder(
                HttpHost.create(&quot;http://192.168.150.101:9200&quot;)
        ));
    &#125;

    @AfterEach
    void tearDown() throws IOException &#123;
        this.client.close();
    &#125;
&#125;
</code></pre>
<h2 id="5-1-新增文档"><a href="#5-1-新增文档" class="headerlink" title="5.1.新增文档"></a>5.1.新增文档</h2><p>我们要将数据库的酒店数据查询出来，写入elasticsearch中。</p>
<h3 id="5-1-1-索引库实体类"><a href="#5-1-1-索引库实体类" class="headerlink" title="5.1.1.索引库实体类"></a>5.1.1.索引库实体类</h3><p>数据库查询后的结果是一个Hotel类型的对象。结构如下：</p>
<pre><code class="java">@Data
@TableName(&quot;tb_hotel&quot;)
public class Hotel &#123;
    @TableId(type = IdType.INPUT)
    private Long id;
    private String name;
    private String address;
    private Integer price;
    private Integer score;
    private String brand;
    private String city;
    private String starName;
    private String business;
    private String longitude;
    private String latitude;
    private String pic;
&#125;
</code></pre>
<p>与我们的索引库结构存在差异：</p>
<ul>
<li>longitude和latitude需要合并为location</li>
</ul>
<p>因此，我们需要定义一个新的类型，与索引库结构吻合：</p>
<pre><code class="java">package cn.itcast.hotel.pojo;

import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
public class HotelDoc &#123;
    private Long id;
    private String name;
    private String address;
    private Integer price;
    private Integer score;
    private String brand;
    private String city;
    private String starName;
    private String business;
    private String location;
    private String pic;

    public HotelDoc(Hotel hotel) &#123;
        this.id = hotel.getId();
        this.name = hotel.getName();
        this.address = hotel.getAddress();
        this.price = hotel.getPrice();
        this.score = hotel.getScore();
        this.brand = hotel.getBrand();
        this.city = hotel.getCity();
        this.starName = hotel.getStarName();
        this.business = hotel.getBusiness();
        this.location = hotel.getLatitude() + &quot;, &quot; + hotel.getLongitude();
        this.pic = hotel.getPic();
    &#125;
&#125;
</code></pre>
<h3 id="5-1-2-语法说明"><a href="#5-1-2-语法说明" class="headerlink" title="5.1.2.语法说明"></a>5.1.2.语法说明</h3><p>新增文档的DSL语句如下：</p>
<pre><code class="json">POST /&#123;索引库名&#125;/_doc/1
&#123;
    &quot;name&quot;: &quot;Jack&quot;,
    &quot;age&quot;: 21
&#125;
</code></pre>
<p>对应的java代码如图：</p>
<p><img src="/assets/image-20210720230027240.png" alt="image-20210720230027240"></p>
<p>可以看到与创建索引库类似，同样是三步走：</p>
<ul>
<li>1）创建Request对象</li>
<li>2）准备请求参数，也就是DSL中的JSON文档</li>
<li>3）发送请求</li>
</ul>
<p>变化的地方在于，这里直接使用client.xxx()的API，不再需要client.indices()了。</p>
<h3 id="5-1-3-完整代码"><a href="#5-1-3-完整代码" class="headerlink" title="5.1.3.完整代码"></a>5.1.3.完整代码</h3><p>我们导入酒店数据，基本流程一致，但是需要考虑几点变化：</p>
<ul>
<li>酒店数据来自于数据库，我们需要先查询出来，得到hotel对象</li>
<li>hotel对象需要转为HotelDoc对象</li>
<li>HotelDoc需要序列化为json格式</li>
</ul>
<p>因此，代码整体步骤如下：</p>
<ul>
<li>1）根据id查询酒店数据Hotel</li>
<li>2）将Hotel封装为HotelDoc</li>
<li>3）将HotelDoc序列化为JSON</li>
<li>4）创建IndexRequest，指定索引库名和id</li>
<li>5）准备请求参数，也就是JSON文档</li>
<li>6）发送请求</li>
</ul>
<p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p>
<pre><code class="java">@Test
void testAddDocument() throws IOException &#123;
    // 1.根据id查询酒店数据
    Hotel hotel = hotelService.getById(61083L);
    // 2.转换为文档类型
    HotelDoc hotelDoc = new HotelDoc(hotel);
    // 3.将HotelDoc转json
    String json = JSON.toJSONString(hotelDoc);

    // 1.准备Request对象
    IndexRequest request = new IndexRequest(&quot;hotel&quot;).id(hotelDoc.getId().toString());
    // 2.准备Json文档
    request.source(json, XContentType.JSON);
    // 3.发送请求
    client.index(request, RequestOptions.DEFAULT);
&#125;
</code></pre>
<h2 id="5-2-查询文档"><a href="#5-2-查询文档" class="headerlink" title="5.2.查询文档"></a>5.2.查询文档</h2><h3 id="5-2-1-语法说明"><a href="#5-2-1-语法说明" class="headerlink" title="5.2.1.语法说明"></a>5.2.1.语法说明</h3><p>查询的DSL语句如下：</p>
<pre><code class="json">GET /hotel/_doc/&#123;id&#125;
</code></pre>
<p>非常简单，因此代码大概分两步：</p>
<ul>
<li>准备Request对象</li>
<li>发送请求</li>
</ul>
<p>不过查询的目的是得到结果，解析为HotelDoc，因此难点是结果的解析。完整代码如下：</p>
<p><img src="/assets/image-20210720230811674.png" alt="image-20210720230811674"></p>
<p>可以看到，结果是一个JSON，其中文档放在一个<code>_source</code>属性中，因此解析就是拿到<code>_source</code>，反序列化为Java对象即可。</p>
<p>与之前类似，也是三步走：</p>
<ul>
<li>1）准备Request对象。这次是查询，所以是GetRequest</li>
<li>2）发送请求，得到结果。因为是查询，这里调用client.get()方法</li>
<li>3）解析结果，就是对JSON做反序列化</li>
</ul>
<h3 id="5-2-2-完整代码"><a href="#5-2-2-完整代码" class="headerlink" title="5.2.2.完整代码"></a>5.2.2.完整代码</h3><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p>
<pre><code class="java">@Test
void testGetDocumentById() throws IOException &#123;
    // 1.准备Request
    GetRequest request = new GetRequest(&quot;hotel&quot;, &quot;61082&quot;);
    // 2.发送请求，得到响应
    GetResponse response = client.get(request, RequestOptions.DEFAULT);
    // 3.解析响应结果
    String json = response.getSourceAsString();

    HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);
    System.out.println(hotelDoc);
&#125;
</code></pre>
<h2 id="5-3-删除文档"><a href="#5-3-删除文档" class="headerlink" title="5.3.删除文档"></a>5.3.删除文档</h2><p>删除的DSL为是这样的：</p>
<pre><code class="json">DELETE /hotel/_doc/&#123;id&#125;
</code></pre>
<p>与查询相比，仅仅是请求方式从DELETE变成GET，可以想象Java代码应该依然是三步走：</p>
<ul>
<li>1）准备Request对象，因为是删除，这次是DeleteRequest对象。要指定索引库名和id</li>
<li>2）准备参数，无参</li>
<li>3）发送请求。因为是删除，所以是client.delete()方法</li>
</ul>
<p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p>
<pre><code class="java">@Test
void testDeleteDocument() throws IOException &#123;
    // 1.准备Request
    DeleteRequest request = new DeleteRequest(&quot;hotel&quot;, &quot;61083&quot;);
    // 2.发送请求
    client.delete(request, RequestOptions.DEFAULT);
&#125;
</code></pre>
<h2 id="5-4-修改文档"><a href="#5-4-修改文档" class="headerlink" title="5.4.修改文档"></a>5.4.修改文档</h2><h3 id="5-4-1-语法说明"><a href="#5-4-1-语法说明" class="headerlink" title="5.4.1.语法说明"></a>5.4.1.语法说明</h3><p>修改我们讲过两种方式：</p>
<ul>
<li>全量修改：本质是先根据id删除，再新增</li>
<li>增量修改：修改文档中的指定字段值</li>
</ul>
<p>在RestClient的API中，全量修改与新增的API完全一致，判断依据是ID：</p>
<ul>
<li>如果新增时，ID已经存在，则修改</li>
<li>如果新增时，ID不存在，则新增</li>
</ul>
<p>这里不再赘述，我们主要关注增量修改。</p>
<p>代码示例如图：</p>
<p><img src="/assets/image-20210720231040875.png" alt="image-20210720231040875"></p>
<p>与之前类似，也是三步走：</p>
<ul>
<li>1）准备Request对象。这次是修改，所以是UpdateRequest</li>
<li>2）准备参数。也就是JSON文档，里面包含要修改的字段</li>
<li>3）更新文档。这里调用client.update()方法</li>
</ul>
<h3 id="5-4-2-完整代码"><a href="#5-4-2-完整代码" class="headerlink" title="5.4.2.完整代码"></a>5.4.2.完整代码</h3><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p>
<pre><code class="java">@Test
void testUpdateDocument() throws IOException &#123;
    // 1.准备Request
    UpdateRequest request = new UpdateRequest(&quot;hotel&quot;, &quot;61083&quot;);
    // 2.准备请求参数
    request.doc(
        &quot;price&quot;, &quot;952&quot;,
        &quot;starName&quot;, &quot;四钻&quot;
    );
    // 3.发送请求
    client.update(request, RequestOptions.DEFAULT);
&#125;
</code></pre>
<h2 id="5-5-批量导入文档"><a href="#5-5-批量导入文档" class="headerlink" title="5.5.批量导入文档"></a>5.5.批量导入文档</h2><p>案例需求：利用BulkRequest批量将数据库数据导入到索引库中。</p>
<p>步骤如下：</p>
<ul>
<li><p>利用mybatis-plus查询酒店数据</p>
</li>
<li><p>将查询到的酒店数据（Hotel）转换为文档类型数据（HotelDoc）</p>
</li>
<li><p>利用JavaRestClient中的BulkRequest批处理，实现批量新增文档</p>
</li>
</ul>
<h3 id="5-5-1-语法说明"><a href="#5-5-1-语法说明" class="headerlink" title="5.5.1.语法说明"></a>5.5.1.语法说明</h3><p>批量处理BulkRequest，其本质就是将多个普通的CRUD请求组合在一起发送。</p>
<p>其中提供了一个add方法，用来添加其他请求：</p>
<p><img src="/assets/image-20210720232105943.png" alt="image-20210720232105943"></p>
<p>可以看到，能添加的请求包括：</p>
<ul>
<li>IndexRequest，也就是新增</li>
<li>UpdateRequest，也就是修改</li>
<li>DeleteRequest，也就是删除</li>
</ul>
<p>因此Bulk中添加了多个IndexRequest，就是批量新增功能了。示例：</p>
<p><img src="/assets/image-20210720232431383.png" alt="image-20210720232431383"></p>
<p>其实还是三步走：</p>
<ul>
<li>1）创建Request对象。这里是BulkRequest</li>
<li>2）准备参数。批处理的参数，就是其它Request对象，这里就是多个IndexRequest</li>
<li>3）发起请求。这里是批处理，调用的方法为client.bulk()方法</li>
</ul>
<p>我们在导入酒店数据时，将上述代码改造成for循环处理即可。</p>
<h3 id="5-5-2-完整代码"><a href="#5-5-2-完整代码" class="headerlink" title="5.5.2.完整代码"></a>5.5.2.完整代码</h3><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p>
<pre><code class="java">@Test
void testBulkRequest() throws IOException &#123;
    // 批量查询酒店数据
    List&lt;Hotel&gt; hotels = hotelService.list();

    // 1.创建Request
    BulkRequest request = new BulkRequest();
    // 2.准备参数，添加多个新增的Request
    for (Hotel hotel : hotels) &#123;
        // 2.1.转换为文档类型HotelDoc
        HotelDoc hotelDoc = new HotelDoc(hotel);
        // 2.2.创建新增文档的Request对象
        request.add(new IndexRequest(&quot;hotel&quot;)
                    .id(hotelDoc.getId().toString())
                    .source(JSON.toJSONString(hotelDoc), XContentType.JSON));
    &#125;
    // 3.发送请求
    client.bulk(request, RequestOptions.DEFAULT);
&#125;
</code></pre>
<h2 id="5-6-小结"><a href="#5-6-小结" class="headerlink" title="5.6.小结"></a>5.6.小结</h2><p>文档操作的基本步骤：</p>
<ul>
<li>初始化RestHighLevelClient</li>
<li>创建XxxRequest。XXX是Index、Get、Update、Delete、Bulk</li>
<li>准备参数（Index、Update、Bulk时需要）</li>
<li>发送请求。调用RestHighLevelClient#.xxx()方法，xxx是index、get、update、delete、bulk</li>
<li>解析结果（Get时需要）</li>
</ul>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

                    <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 ilovend的博客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;ilovend
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

                </div>
            </transition>
            
            <transition name="fade">
                <div id="preview" ref="preview" v-show="previewShow">
                    <img id="preview-content" ref="previewContent" />
                </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        
<script
    src="https://giscus.app/client.js"
    data-repo="ilovend/ilovend.github.io"
    data-repo-id="R_kgDOI_VOow"
    data-category="Announcements"
    data-category-id="DIC_kwDOI_VOo84CWP7g"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light"
    data-lang="zh-CN"
    crossorigin
    async
></script>





        
    </body>
</html>
